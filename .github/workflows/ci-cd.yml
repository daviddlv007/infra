name: CI/CD - build, push to GHCR & deploy to EC2

on:
  push:
    branches: [ "main" ]

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build & push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ghcr.io/daviddlv007/infra/backend:latest

      - name: Build & push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ghcr.io/daviddlv007/infra/frontend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to EC2 via SSH and run compose
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail

            # ruta del proyecto en EC2
            PROJ_DIR="/home/${{ secrets.EC2_USER }}/prueba-infra/infra"
            cd "$PROJ_DIR"

            echo ">>> LOGIN a GHCR en EC2"
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            echo ">>> 1) Pull de imágenes desde GHCR"
            docker-compose -f docker-compose.prod.yml pull || true

            echo ">>> 2) Si NO existe certificado, activar lite y emitir (ACME webroot)"
            if [ ! -f /etc/letsencrypt/live/softwaredlv.duckdns.org/fullchain.pem ]; then
              echo "No existe certificado: activando default.lite.conf temporalmente"
              cp nginx/conf.d_other/default.lite.conf nginx/conf.d_active/default.active.conf
              docker-compose -f docker-compose.prod.yml up -d proxy

              echo "Emitiendo certificado con certbot (webroot)..."
              docker-compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot \
                certbot certonly --webroot -w /var/www/letsencrypt \
                -d softwaredlv.duckdns.org \
                --email "${{ secrets.CERTBOT_EMAIL }}" --agree-tos --no-eff-email || true
            else
              echo "Certificado ya existente: saltando emisión inicial."
            fi

            echo ">>> 3) Activar configuración prod (HTTPS) y arrancar todo el stack"
            cp nginx/conf.d_other/default.prod.conf nginx/conf.d_active/default.active.conf || true
            docker-compose -f docker-compose.prod.yml up -d --pull always --force-recreate

            echo ">>> 4) Limpieza de imágenes intermedias"
            docker image prune -f || true

            echo ">>> 5) Verificación de renovación (dry-run, forzando webroot)"
            docker-compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot \
              certbot renew --dry-run --webroot -w /var/www/letsencrypt || true

            echo ">>> Despliegue completado."
